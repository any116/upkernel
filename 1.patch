diff --git a/target/linux/mediatek/patches-6.6/999-2133-pwm-mediatek-add-longer-period-support.patch b/target/linux/mediatek/patches-6.6/999-2133-pwm-mediatek-add-longer-period-support.patch
index b9489f4177f..3a08e3067f6 100644
--- a/target/linux/mediatek/patches-6.6/999-2133-pwm-mediatek-add-longer-period-support.patch
+++ b/target/linux/mediatek/patches-6.6/999-2133-pwm-mediatek-add-longer-period-support.patch
@@ -26,7 +26,7 @@ index 9701092e7..79d15a9c0 100644
  	unsigned long clk_rate;
  	u64 resolution;
  
-@@ -164,12 +167,30 @@ static int pwm_mediatek_config(struct pwm_chip *chip, struct pwm_device *pwm,
+@@ -164,15 +167,33 @@ static int pwm_mediatek_config(struct pwm_chip *chip, struct pwm_device *pwm,
  
  	/* Using resolution in picosecond gets accuracy higher */
  	resolution = (u64)NSEC_PER_SEC * 1000;
@@ -37,7 +37,10 @@ index 9701092e7..79d15a9c0 100644
 +	 * the effective range of the PWM period counter
 +	 */
  	cnt_period = DIV_ROUND_CLOSEST_ULL((u64)period_ns * 1000, resolution);
- 	while (cnt_period > 8191) {
+ 	if (!cnt_period)
+ 		return -EINVAL;
+
+ 	while (cnt_period > 8192) {
 +		/* Using clkdiv to reduce clock frequency and calculate
 +		 * new resolution based on new clock speed
 +		 */
@@ -58,21 +61,22 @@ index 9701092e7..79d15a9c0 100644
  		cnt_period = DIV_ROUND_CLOSEST_ULL((u64)period_ns * 1000,
  						   resolution);
  	}
-@@ -189,8 +210,13 @@ static int pwm_mediatek_config(struct pwm_chip *chip, struct pwm_device *pwm,
+@@ -189,9 +210,14 @@ static int pwm_mediatek_config(struct pwm_chip *chip, struct pwm_device *pwm,
  		reg_thres = PWM45THRES_FIXUP;
  	}
  
 +	/* Calculate cnt_duty based on resolution */
  	cnt_duty = DIV_ROUND_CLOSEST_ULL((u64)duty_ns * 1000, resolution);
+
 -	pwm_mediatek_writel(pc, pwm->hwpwm, PWMCON, BIT(15) | clkdiv);
 +	if (clksel)
 +		pwm_mediatek_writel(pc, pwm->hwpwm, PWMCON, BIT(15) | BIT(3) |
 +				    clkdiv);
 +	else
 +		pwm_mediatek_writel(pc, pwm->hwpwm, PWMCON, BIT(15) | clkdiv);
- 	pwm_mediatek_writel(pc, pwm->hwpwm, reg_width, cnt_period);
- 	pwm_mediatek_writel(pc, pwm->hwpwm, reg_thres, cnt_duty);
+ 	pwm_mediatek_writel(pc, pwm->hwpwm, reg_width, cnt_period - 1);
  
+	if (cnt_duty) {
 -- 
 2.34.1
 
diff --git a/target/linux/mediatek/patches-6.6/999-2136-add-pwm-hw-breathing-light-feature.patch b/target/linux/mediatek/patches-6.6/999-2136-add-pwm-hw-breathing-light-feature.patch
index 41f6443b1e9..a48f7166a2f 100644
--- a/target/linux/mediatek/patches-6.6/999-2136-add-pwm-hw-breathing-light-feature.patch
+++ b/target/linux/mediatek/patches-6.6/999-2136-add-pwm-hw-breathing-light-feature.patch
@@ -128,12 +128,12 @@ Subject: [PATCH] add pwm hw breathing light support for mt7987
  	u32 clkdiv = 0, clksel = 0, cnt_period, cnt_duty,
  	    reg_width = PWMDWIDTH, reg_thres = PWMTHRES;
  	u64 resolution;
-+	u32 max_cnt_period = 8191;
++	u32 max_cnt_period = 8192;
 +	int thres_num;
  	int ret;
  
  	ret = pwm_mediatek_clk_enable(chip, pwm);
-@@ -143,15 +232,24 @@ static int pwm_mediatek_config(struct pw
+@@ -169,6 +169,12 @@ static int pwm_mediatek_config(struct pw
  	if (pc->soc->has_ck_26m_sel)
  		writel(0, pc->regs + PWM_CK_26M_SEL);
  
@@ -145,36 +145,29 @@ Subject: [PATCH] add pwm hw breathing light support for mt7987
 +
  	/* Using resolution in picosecond gets accuracy higher */
  	resolution = (u64)NSEC_PER_SEC * 1000;
-+
  	/* Calculate resolution based on current clock frequency */
- 	do_div(resolution, clk_rate);
-+
- 	/* Using resolution to calculate cnt_period which represents
- 	 * the effective range of the PWM period counter
- 	 */
- 	cnt_period = DIV_ROUND_CLOSEST_ULL((u64)period_ns * 1000, resolution);
--	while (cnt_period > 8191) {
-+
+@@ -180,7 +186,7 @@ static int pwm_mediatek_config(struct pw
+ 	if (!cnt_period)
+ 		return -EINVAL;
+ 
+-	while (cnt_period > 8192) {
 +	while (cnt_period > max_cnt_period) {
  		/* Using clkdiv to reduce clock frequency and calculate
  		 * new resolution based on new clock speed
  		 */
-@@ -195,8 +293,14 @@ static int pwm_mediatek_config(struct pw
+@@ -284,7 +382,12 @@ static int pwm_mediatek_config(struct pw
  				    clkdiv);
  	else
  		pwm_mediatek_writel(pc, pwm->hwpwm, PWMCON, BIT(15) | clkdiv);
 +
- 	pwm_mediatek_writel(pc, pwm->hwpwm, reg_width, cnt_period);
--	pwm_mediatek_writel(pc, pwm->hwpwm, reg_thres, cnt_duty);
+ 	pwm_mediatek_writel(pc, pwm->hwpwm, reg_width, cnt_period - 1);
 +
 +	/* use array of bw_thres instead of normal thres in bw_mode */
 +	if (pc->bw_mode[pwm->hwpwm])
 +		pwm_config_bl_thres(pc, pwm->hwpwm, cnt_period, thres_num);
-+	else
-+		pwm_mediatek_writel(pc, pwm->hwpwm, reg_thres, cnt_duty);
- 
- 	pwm_mediatek_clk_disable(chip, pwm);
  
+ 	if (cnt_duty) {
+ 		pwm_mediatek_writel(pc, pwm->hwpwm, reg_thres, cnt_duty - 1);
 @@ -264,6 +368,7 @@ static const struct pwm_ops pwm_mediatek
  
  static int pwm_mediatek_probe(struct platform_device *pdev)
diff --git a/target/linux/mediatek/patches-6.6/999-2800-trng-driver-porting.patch b/target/linux/mediatek/patches-6.6/999-2800-trng-driver-porting.patch
index 196f16eebd1..120f1ebdaf4 100644
--- a/target/linux/mediatek/patches-6.6/999-2800-trng-driver-porting.patch
+++ b/target/linux/mediatek/patches-6.6/999-2800-trng-driver-porting.patch
@@ -126,14 +126,16 @@
  
  	ret = devm_hwrng_register(&pdev->dev, &priv->rng);
  	if (ret) {
-@@ -139,11 +189,6 @@ static int mtk_rng_probe(struct platform
+@@ -189,13 +189,6 @@ static int mtk_rng_probe(struct platform
  		return ret;
  	}
  
 -	dev_set_drvdata(&pdev->dev, priv);
 -	pm_runtime_set_autosuspend_delay(&pdev->dev, RNG_AUTOSUSPEND_TIMEOUT);
 -	pm_runtime_use_autosuspend(&pdev->dev);
--	devm_pm_runtime_enable(&pdev->dev);
+-	ret = devm_pm_runtime_enable(&pdev->dev);
+-	if (ret)
+-		return ret;
 -
  	dev_info(&pdev->dev, "registered RNG driver\n");
  
diff --git a/target/linux/mediatek/patches-6.6/999-3028-mtk-wed-add-hwpath-wmm-support.patch b/target/linux/mediatek/patches-6.6/999-3058-mtk-wed-add-hwpath-wmm-support.patch
index b0fd21b08b9..6e28d14769b 100644
--- a/target/linux/mediatek/patches-6.6/999-3028-mtk-wed-add-hwpath-wmm-support.patch
+++ b/target/linux/mediatek/patches-6.6/999-3028-mtk-wed-add-hwpath-wmm-support.patch
@@ -50,7 +50,7 @@ diff --git a/drivers/net/ethernet/mediatek/mtk_ppe_offload.c b/drivers/net/ether
 index f4657dd..8304f92 100644
 --- a/drivers/net/ethernet/mediatek/mtk_ppe_offload.c
 +++ b/drivers/net/ethernet/mediatek/mtk_ppe_offload.c
-@@ -91,29 +91,31 @@ mtk_flow_offload_mangle_eth(const struct flow_action_entry *act, void *eth)
+@@ -93,31 +93,29 @@ mtk_flow_offload_mangle_eth(const struct
  static int
  mtk_flow_get_wdma_info(struct net_device *dev, const u8 *addr, struct mtk_wdma_info *info)
  {
@@ -68,19 +68,22 @@ index f4657dd..8304f92 100644
  	if (!IS_ENABLED(CONFIG_NET_MEDIATEK_SOC_WED))
  		return -1;
  
+-	rcu_read_lock();
 -	err = dev_fill_forward_path(dev, addr, &stack);
+-	rcu_read_unlock();
 -	if (err)
 -		return err;
 +	if (!dev->netdev_ops->ndo_fill_forward_path)
 +		return -1;
- 
--	path = &stack.path[stack.num_paths - 1];
--	if (path->type != DEV_PATH_MTK_WDMA)
-+	memcpy(ctx.daddr, addr, sizeof(ctx.daddr));
 +
++	memcpy(ctx.daddr, addr, sizeof(ctx.daddr));
 +	path.mtk_wdma.tid = info->tid;
-+
 +	if (dev->netdev_ops->ndo_fill_forward_path(&ctx, &path))
++		return -1;
+ 
+-	path = &stack.path[stack.num_paths - 1];
+-	if (path->type != DEV_PATH_MTK_WDMA)
++	if (path.type != DEV_PATH_MTK_WDMA)
  		return -1;
  
 -	info->wdma_idx = path->mtk_wdma.wdma_idx;
@@ -88,9 +91,6 @@ index f4657dd..8304f92 100644
 -	info->bss = path->mtk_wdma.bss;
 -	info->wcid = path->mtk_wdma.wcid;
 -	info->amsdu = path->mtk_wdma.amsdu;
-+	if (path.type != DEV_PATH_MTK_WDMA)
-+		return -1;
-+
 +	memcpy(info, &path.mtk_wdma, sizeof(*info));
  
  	return 0;
